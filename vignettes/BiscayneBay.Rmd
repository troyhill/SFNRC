---
title: 'Water quality in Biscayne Bay: Status and trends'
subtitle: ''
output: 
  pdf_document: 
    latex_engine: pdflatex
vignette: >
  %\VignetteIndexEntry{DataForEver}
  %\VignetteEngine{knitr::knitr}
  %\usepackage[UTF-8]{inputenc}
mainfont: FreeMono
header-includes:
- \usepackage{pdflscape}
- \newcommand{\blandscape}{\begin{landscape}}
- \newcommand{\elandscape}{\end{landscape}}
- \usepackage[utf8]{inputenc}
---

```{r setup, include=FALSE, echo=FALSE}

### TODO: amend bnp to include bay subregions used for regulatory water quality criteria, or include additional polygon files in package



if(!require(knitr)){
  install.packages("knitr", repos='http://cran.us.r-project.org')
}
if(!require(rmarkdown)){
  install.packages("rmarkdown", repos='http://cran.us.r-project.org')
}
if(!require(plyr)){
  install.packages("plyr", repos='http://cran.us.r-project.org')
}
if(!require(reshape2)){
  install.packages("reshape2", repos='http://cran.us.r-project.org')
}
if(!require(ggplot2)){
  install.packages("ggplot2", repos='http://cran.us.r-project.org')
}
if(!require(scales)){
  install.packages("scales", repos='http://cran.us.r-project.org')
}
if(!require(maptools)){ # this package may be unnecessary
  install.packages("scales", repos='http://cran.us.r-project.org')
}
if(!require(rgeos)){
  install.packages("rgeos", repos='http://cran.us.r-project.org')
}
if(!require(deldir)){
  install.packages("deldir", repos='http://cran.us.r-project.org')
}

# then load the package:
library(knitr)
library(rmarkdown)
library(plyr)
library(reshape2)
library(ggplot2)
library(scales)
library(SFNRC)

library(maptools)
library(rgeos)
library(sp)
library(dismo)
library(deldir)
library(gstat)
library(rgdal)
library(raster)

knitr::opts_chunk$set(echo = TRUE, comment=NA)
```

## Summary

Water quality trends in Biscayne Bay were evaluated using data from DataForEver and the Miami-Dade Department of Environmental Resources Management. Spatial and temporal trends were evaluated for subregions of the bay using interpolated raster layers for each water quality parameter. This approach minimizes, but does not eliminate, artifacts introduced by varying sampling locations. The effect of canal inflows on water quality in Biscayne Bay was also evaluated.


\vspace{3mm}\hrule

**Keywords:** Biscayne Bay, water quality


```{r, echo = FALSE, include=FALSE}
# if the NitrogenUptake2016 package isn't installed, use devtools to do so:
# devtools::install_github("troyhill/NitrogenUptake2016", build_vignettes = TRUE)

# set some constants
todaysDate <- substr(as.character(Sys.time()), 1, 10)
pointSize <- 2 # for ggplot graphics
pd <- pd2 <- position_dodge(1.2)
pd3 <- position_dodge(0.8)
grayColor <- 0.55
fig2Col   <- "gray55"


compareParams <- c("AMMONIA-N", "NITRATE+NITRITE-N",
                   "SALINITY", "PH, FIELD", "CHLOROPHYLL-A", "TURBIDITY", "DISSOLVED OXYGEN", 
                   "PHOSPHATE, TOTAL AS P", "PHOSPHATE, ORTHO AS P")

## compiled water quality data - regenerate this.
summary(finDat)  # bay water quality data - merged with latest DERM data
summary(wqDat)   # canal water quality data (DERM data not likely to be relevant)

## hydrology data
summary(hydDat)  # canal inflows


```



## Water quality trends in Biscayne Bay


**1.1 Annual water quality trends in Biscayne Bay**

- Calculated annual geometric means, by station, for each calendar year

- Interpolated over entire bay, then extracted summary statistics for subregions

- Statistical analysis of trends: loess decomposition, breakpoints


```{r interpolated water quality rasters, echo=FALSE, include=FALSE}

# http://rspatial.org/analysis/rst/4-interpolation.html ------------------
fin2 <- dcast(finDat[, -c(4, 7)], stn + date + year ~ param) # long to wide
fin2 <- seas(fin2, timeCol = "date")
fin2$seas2  <- paste0(fin2$waterYr,"-", fin2$seas)


# Create interpolated maps of annual geometric means ----------------------
### Data are not finalized, so this is just laying out the conceptual approach. Interpolate for the whole bay and then clip for regions.
agm <- plyr::ddply(fin2[, -c(2)], plyr::.(year, stn), plyr::numcolwise(geoMean))
names(agm) <- gsub(x = names(agm), pattern = " |,", replacement = "")
names(agm) <- gsub(x = names(agm), pattern = "-|[+]", replacement = ".")


finDat.coords <- plyr::join_all(list(agm, masterCoords), by = "stn")
finDat.coords <- finDat.coords[!is.na(finDat.coords$long), ]

coordinates(finDat.coords) <- c("long", "lat")
proj4string(finDat.coords) <- CRS("+proj=longlat +datum=WGS84 +no_defs +ellps=WGS84 +towgs84=0,0,0")

sitesInBay <- sp::over(finDat.coords, bnp)
sitesInBay <- finDat.coords[complete.cases(sitesInBay), ]



# kriging --------------------------------------------------------------
# biscInterp(inputData = sitesInBay,paramCol = "SALINITY", year = "2016")
    
    ### store raster layer in working environment
# biscRas <- biscInterp(inputData = sitesInBay,
    # paramCol = "SALINITY", year = "2016", returnRas = TRUE)


# ### 
# targParam <- "SALINITY"
# targYear  <- "2016"
# a <- biscInterp(inputData = sitesInBay, 
#            paramCol = targParam, year = targYear, yearCol = "year", returnRas = TRUE)
           
for (j in c(5, 10)) { #4:(length(names(sitesInBay) - 1))) {
  dat.l <- list()
  for (i in 33:length(unique(sitesInBay$year))) {
    targYear  <- unique(sitesInBay$year)[i]
    targParam <- names(sitesInBay)[j] # "SALINITY" 
    targDat   <- sitesInBay
    lims      <- as.numeric(quantile(data.frame(targDat@data[, targParam]), c(0, 1), na.rm = TRUE))
    try(
      dat.l[[paste0(targParam, targYear)]] <- biscInterp(inputData = targDat, paramCol = targParam, year = targYear, yearCol = "year", plotZLims = lims, returnRas = TRUE)
    )
  }
  ### summarize data after compiling rasters for each parameter
  # https://gis.stackexchange.com/questions/270988/raster-data-extract-to-polygon-rcode
  # possible approach would be to create a raster stack (https://gis.stackexchange.com/questions/29118/how-to-find-the-average-raster-value-of-an-area-defined-by-a-shapefile-using-r)
  # get mean and area <20 psu for bay subregions 
  ### example for entire raster:
  # test     <- ldply(dat.l, function(x) cellStats(x, "mean"))
  ### for subregions:
  if (!exists("adat")) {
    adat    <- ldply(dat.l, function(x) t(extract(x, bnp, fun = mean, na.rm = TRUE)))
    adat.20 <- ldply(dat.l, function(x) t(extract(x, bnp, fun = function(x,...)ecdf(x)(20), na.rm = TRUE))) # proportion of total area below 20 (for salinity)
    adat.sd <- ldply(dat.l, function(x) t(raster::extract(x, bnp, fun = sd, na.rm = TRUE)))
  } else { ### if this isn't the first iteration, merge with existing dataframes
    adat    <- rbind(adat, ldply(dat.l, function(x) t(extract(x, bnp, fun = mean, na.rm = TRUE))))
    adat.20 <- rbind(adat.20, ldply(dat.l, function(x) t(extract(x, bnp, fun = function(x,...)ecdf(x)(20), na.rm = TRUE))))
    adat.sd <- rbind(adat.sd, ldply(dat.l, function(x) t(raster::extract(x, bnp, fun = sd, na.rm = TRUE))))
  }
}

### to make a wide dataset:
# names(adat)[-1] <- paste0("mean.", bnp@data$OBJECTID)
# names(adat.20)[-1] <- paste0("cellsSub20.", bnp@data$OBJECTID)
# names(adat.sd)[-1] <- paste0("sd.", bnp@data$OBJECTID)
# combd       <- join_all(list(adat, adat.sd, adat.20))

### to make a long dataset with columns: param, year, loc, mean, sd, ecdf20
combd <- join_all(list(
  melt(adat, id.vars = 1, variable.name = "subregion", value.name = "mean"),
  melt(adat.sd, id.vars = 1, variable.name = "subregion", value.name = "sd"),
  melt(adat.20, id.vars = 1, variable.name = "subregion", value.name = "propSub20")
))

combd$param <- substr(combd[, 1], 1, nchar(combd[, 1]) - 4)
combd$yr    <- as.numeric(substr(combd[, 1], nchar(combd[, 1]) - 3, nchar(combd[, 1])))

### change subregion from region number to objectID (can easily be replaced by another column)
combd$subregion <- as.character(bnp@data$OBJECTID)[as.numeric(as.character(combd$subregion))]


# ggplot(combd, aes(y = mean, x = yr, col = subregion)) + geom_point() + geom_pointrange(aes(ymin = mean - sd, ymax = mean + sd)) + theme_classic() + facet_grid(param ~ ., scales = "free_y") + ylab("")

### I can't figure out how to generate multiple columns at the same time, avoiding the need to join_all. e.g., this doesn't work:
# test <- ldply(sal.list, summarise,
#               # name = names(x),
#               mean = function(x) cellStats(x, "mean"),
#               area_sub20 = function(x) cellStats(x, "ecdf(x)(20)"))

# 
# ### now repeat for all parameters
# wq.list <- list()
# for (j in 4:(length(names(sitesInBay)) - 1)) {
#   for (i in 1:length(unique(sitesInBay$year))) {
#     targYear  <- unique(sitesInBay$year)[i]
#     targParam <- names(sitesInBay)[j]
#     targDat   <- sitesInBay
#     lims      <- as.numeric(quantile(data.frame(targDat@data[, targParam]), c(0, 1), na.rm = TRUE))
#     wq.list[i] <- biscInterp(inputData = targDat, paramCol = targParam, year = targYear, yearCol = "year", plotZLims = lims,returnRas = TRUE)
#     names(wq.list)[i] <- paste0(targParam, targYear)
#   }
# }
# 
# test <- ldply(wq.list, function(x) cellStats(x, "mean"))

```



```{r Subregion map, fig.width = 4, fig.height = 4, message = FALSE, echo=FALSE}
par(mar = c(4,4,0.5,0.5))
plot(bnp, col = bnp@data$OBJECTID)
pointLabel(coordinates(bnp), labels = bnp$OBJECTID)

```
Figure 1. Map of sub-regions used in Biscayne Bay, with numeric labels. 



```{r parameter trends, fig.width = 6, fig.height = 4, message = FALSE, echo=FALSE}
ggplot(combd, aes(y = mean, x = yr, col = subregion)) + #geom_point(size  = 1, position = pd3) + 
  geom_pointrange(aes(ymin = mean - sd, ymax = mean + sd), position = pd3, fatten = 1) + theme_classic() + facet_grid(param ~ ., scales = "free_y") + ylab("") 

```
Figure 2. Annual water quality trends for Biscayne Bay subregions. Spatially-weighted mean (+- SD) of interpolated annual geometric means from individual stations.





**1.1.	 Annual trends in wet season water quality **
```{r interpolated wet season data, echo = FALSE, include = FALSE, message = FALSE}
### same as above but for wet season.
### memory constraints may require saving rasters to disk or instantly summarizing & deleting them
fin2 <- dcast(finDat[, -c(4, 7)], stn + date + year ~ param) # long to wide
fin2 <- seas(fin2, timeCol = "date")
fin2$seas2  <- paste0(fin2$waterYr,"-", fin2$seas)


# Create interpolated maps of geometric means ----------------------
agm <- plyr::ddply(fin2[, -c(grep(x = names(fin2), pattern = "date|water"))], plyr::.(seas2, seas, year, stn), plyr::numcolwise(geoMean))
names(agm) <- gsub(x = names(agm), pattern = " |,", replacement = "")
names(agm) <- gsub(x = names(agm), pattern = "-|[+]", replacement = ".")


finDat.coords <- plyr::join_all(list(agm, masterCoords), by = "stn")
finDat.coords <- finDat.coords[!is.na(finDat.coords$long), ]

coordinates(finDat.coords) <- c("long", "lat")
proj4string(finDat.coords) <- CRS("+proj=longlat +datum=WGS84 +no_defs +ellps=WGS84 +towgs84=0,0,0")

sitesInBay <- sp::over(finDat.coords, bnp)
sitesInBay <- finDat.coords[complete.cases(sitesInBay), ]


for (j in c(7, 12)) { #5:(length(names(sitesInBay) - 1))) {
  seas.l <- list()
  for (i in 1:length(unique(sitesInBay$seas2))) {
    targYear  <- unique(sitesInBay$seas2)[i]
    targParam <- names(sitesInBay)[j] # "SALINITY" 
    targDat   <- sitesInBay
    lims      <- as.numeric(quantile(data.frame(targDat@data[, targParam]), c(0, 1), na.rm = TRUE))
    try(
      seas.l[[paste0(targParam, targYear)]] <- biscInterp(inputData = targDat, paramCol = targParam, year = targYear, yearCol = "seas2", plotZLims = lims, returnRas = TRUE)
      )
    # names(dat.l)[i] <- paste0(targParam, targYear)
  }
  if (!exists("adat.seas")) {
    adat.seas    <- ldply(seas.l, function(x) t(extract(x, bnp, fun = mean, na.rm = TRUE)))
    adat.seas.20 <- ldply(seas.l, function(x) t(extract(x, bnp, fun = function(x,...)ecdf(x)(20), na.rm = TRUE))) # proportion of total area below 20 (for salinity)
    adat.seas.sd <- ldply(seas.l, function(x) t(raster::extract(x, bnp, fun = sd, na.rm = TRUE)))
  } else { ### if this isn't the first iteration, merge with existing dataframes
    adat.seas    <- rbind(adat.seas,    ldply(seas.l, function(x) t(extract(x, bnp, fun = mean, na.rm = TRUE))))
    adat.seas.20 <- rbind(adat.seas.20, ldply(seas.l, function(x) t(extract(x, bnp, fun = function(x,...)ecdf(x)(20), na.rm = TRUE))))
    adat.seas.sd <- rbind(adat.seas.sd, ldply(seas.l, function(x) t(raster::extract(x, bnp, fun = sd, na.rm = TRUE))))
  }
}


### to make a long dataset with columns: param, year, loc, mean, sd, ecdf20

combd.seas <- join_all(list(
  melt(adat.seas, id.vars = 1, variable.name = "subregion", value.name = "mean"),
  melt(adat.seas.sd, id.vars = 1, variable.name = "subregion", value.name = "sd"),
  melt(adat.seas.20, id.vars = 1, variable.name = "subregion", value.name = "propSub20")
))

combd.seas$param <- substr(combd.seas[, 1], 1, nchar(combd.seas[, 1]) - 8)
combd.seas$yr    <- as.numeric(substr(combd.seas[, 1], nchar(combd.seas[, 1]) - 7, nchar(combd.seas[, 1]) - 4))
combd.seas$seas  <- substr(combd.seas[, 1], nchar(combd.seas[, 1]) - 2, nchar(combd.seas[, 1]))


### change subregion from region number to objectID (can easily be replaced by another column)
combd.seas$subregion <- as.character(bnp@data$OBJECTID)[as.numeric(as.character(combd.seas$subregion))]


```


```{r annual wet/dry season trends, fig.width = 6, fig.height = 4, message = FALSE, echo=FALSE}
ggplot(combd.seas, aes(y = mean, x = yr, col = subregion)) + #geom_point(size  = 0.25, position = pd3) + 
  geom_pointrange(aes(ymin = mean - sd, ymax = mean + sd), position = pd3, fatten = 1) + theme_classic() + facet_grid(param ~ seas, scales = "free_y") + ylab("") 

```

**1.2.	 Annual trends in dry season water quality **



**1.3.	 Monthly trends in water quality **

Will run into serious memory issues



## 2. Effect of canals

**2.1.	 Quantifying water inflows**


```{r annual water inflows from canals, include=FALSE, echo=FALSE}
structs <- c("S20", "S20F", "S20G", "S21A", "S21", "S22", "S25", "S25A", "S25B", "S26", "S27", "S28", "G58", "S700", "G93", "S123", "S197")

biscHyd <- hydDat[hydDat$stn %in% structs, ]



```



Flows through \code{structs} were used to calculate annual water inflow to the bay through canals.



mass = (height$\cdot$a + b)^1/$\lambda$^ 


```{r Figure 1 (Data In Brief), fig.width = 6, fig.height = 4, message = FALSE, include=FALSE, echo=FALSE}

```



